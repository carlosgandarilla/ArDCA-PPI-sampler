#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
"""
	'computeCijk'
Computes three-point correlations for specific triplets:

* 'data': data after one-hot encoding, 
* 'weights': are weights for each sequences, 
* 'freq': one-point frequenties, 
* 'fij': two-points frequenties, 
* 'triplets': are specific triplets.
"""

function computeCijk(data::BitArray{3}, 
		weights::Vector{Float64}, 
		freq::Vector{Float64}, 
		fij::Matrix{Float64}, 
		triplets::Vector{Tuple{Int64, Int64, Int64}})

	#data data after one-hot encoding, 
	#weights are weights for each sequences, 
	#freq one-point frequenties, 
	#fij two-points frequenties, 
	#triplets are specific triplets.
    
    #---------------------------------------------------------------------------------------
    # 
    q, L, M = size(data)
    n_points = length(triplets)
    cat_data = oneHot2Categorical(data, q)
    
    #---------------------------------------------------------------------------------------
    # Computes three-point frequencies for specific triplets
    fijk = computeFijk(cat_data, weights, triplets, q)
    
    #---------------------------------------------------------------------------------------
    # Computes three-point correlations for specific triplets
    cijk = zeros(Float32, n_points, q, q, q)
    
    @inbounds for (idx, (i, j, k)) in enumerate(triplets)
        @inbounds for qi in 1:q, qj in 1:q, qk in 1:q
            f123 = freq[id(i, qi, q)] * freq[id(j, qj, q)] * freq[id(k, qk, q)]
            fij_k = fij[id(i, qi, q), id(j, qj, q)] * freq[id(k, qk, q)]
            fik_j = fij[id(i, qi, q), id(k, qk, q)] * freq[id(j, qj, q)]
            fjk_i = fij[id(j, qj, q), id(k, qk, q)] * freq[id(i, qi, q)]
            cijk[idx, qi, qj, qk] = fijk[idx, qi, qj, qk] - fij_k - fik_j - fjk_i + 2 * f123
        end
    end
    
    return vec(cijk)
    
end




#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
"""
	'computeFijk' 
Computes three-point frequencies for specific triplets:

* 'data': data after one-hot encoding, 
* 'weights': are weights for each sequences, 
* 'triplets': are specific triplets,
* 'q': is the number of states (= 21) for amino-acids data.
"""

function computeFijk(data::Matrix{Int16}, 
		weights::Vector{Float64}, 
		triplets::Vector{Tuple{Int64, Int64, Int64}}, 
		q::Int)
    
    #data data after one-hot encoding, 
    #weights are weights for each sequences, 
    #triplets are specific triplets,
    #q is the number of states (= 21) for amino-acids data.

    L, M = size(data) # data is CATEGORICAL 
    n_points = length(triplets)
    
    #---------------------------------------------------------------------------------------
    # Computes three-point frequencies for specific triplets
    fijk = zeros(Float32, n_points, q, q, q)
    @inbounds for m in 1:M 
        @inbounds for (idx, (i, j, k)) in enumerate(triplets)
            fijk[idx, data[i, m], data[j, m], data[k, m]] += weights[m]
        end
    end
     
    return fijk / sum(weights)
end




#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
"""
	'createTriplets' 
Creates triplets 'n_triplets' from all possible ùêø√óùêø√óùêø:

* 'L' is the number of amino-acids,
* 'n_triplets' is the amount of triplets to take from ùêø√óùêø√óùêø all possible triplets.
"""

function createTriplets(L::Int64, 
		n_triplets::Int64)
    
    #L is the number of amino-acids,
    #n_triplets is the amount of triplets to take from ùêø√óùêø√óùêø all possible triplets.
		
    #---------------------------------------------------------------------------------------
    # Generates all possible triplets
    triplets = Tuple{Int64, Int64, Int64}[]
    @inbounds for i = 1:L, j = 1:L, k = 1:L
        push!(triplets, (i,j,k))
    end
    
    #---------------------------------------------------------------------------------------
    # Takes just a sample of 'n_triplets' from all possible triplets
    if n_triplets < L^3
    	trip = StatsBase.sample(1:L^3, n_triplets; replace=false)
    elseif n_triplets >= L^3
    	trip = collect(1:L^3)
    elseif n_triplets <= 0
    	println("Error: number of triplets should be larger than 0")
    end
    
    return triplets[trip]
end




#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
"""
	'oneHot2Categorical'

"""

function oneHot2Categorical(oneHotV::BitArray{3}, Nq::Int64)
    Nq, Nv, Ns = size(oneHotV)
    V = zeros(Int16, Nv, Ns)
    all_v = collect(1:Nq)
    @inbounds for i_s in 1:Ns, i_v in 1:Nv
        V[i_v, i_s] = findfirst(x -> x==1, oneHotV[:, i_v, i_s])
    end
    return V
end

#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
"""
	'oneHotEncoding'

"""

function oneHotEncoding(V::Matrix{Int8})
    q = maximum(V)
    L, M = size(V)
    oneHotV = BitArray(undef, q, L, M)
    all_v = collect(1:q)
    @inbounds for i_s in 1:M, i_v in 1:L
        oneHotV[:, i_v, i_s] = (all_v .== V[i_v, i_s])
    end
    return oneHotV
end




#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
"""
	'vectorize_mat'
Vectorize a Hamming distance matrix 'dij' taking the upper triangle (except diagonal).
It avoids diagonal elements (dij[i,i] = 0) and symmetric elements (dij[i,j] = dij[j,i]):

* 'x': is a square matrix of size M x M,
* 'M': is the dimension of matrix 'x'.
"""
function vectorize_mat(x::Matrix, 
		M::Int)

    #x is a square matrix of size M x M.
    #M is the dimension of matrix.

    #---------------------------------------------------------------------------------------
    # Takes the upper triangle of matrix 'x'. 
    vec_x = Int[]

    for i = 1:M-1, j = i+1:M
        push!(vec_x, x[i,j])
    end
    
    return vec_x
    
end




#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------
"""
....
"""

id(i, a, q) = (i .- 1).*q .+ a
    


#-------------------------------------------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------------------------------------------------------------------------------------------------------

